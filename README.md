# 1) Простой интерпретатор Lisp

Написать интерпретатор для небольшого Lisp-подобного языка. 
Это задание проверяет проектирование типов данных, парсинг и управление состоянием 
(или рекурсию) для вычислений.

## 1.1 Описание

Определите тип данных для S-выражений (Символических Выражений), которые являются 
ядром Lisp. Выражение может быть атомом (числом или символом) или списком других выражений.

```haskell
-- | Тип данных для S-выражений (Lisp-подобный синтаксис)
data SExpr
  = Atom   String           -- символ / имя переменной
  | Number Integer          -- целое число
  | List   [SExpr]          -- список выражений (в том числе вызов функции)
  deriving (Show, Eq)
```

Ваш интерпретатор должен уметь вычислять эти выражения.

### 1.1.1 Часть 1: Вычислитель

Напишите функцию eval, которая принимает выражение и окружение 
(отображение имен переменных в значения) и возвращает новое выражение (результат).

• Числа вычисляются в самих себя.
• Символы (Атомы) ищутся в окружении.
• Списки — это вызовы функций. Первый элемент — функция, остальные — аргументы.

Реализуйте следующие встроенные функции и специальные формы:

* (+), (-), (*), (>) 
* (if condition then-expr else-expr)
* (define var-name value) — добавляет переменную в окружение

### 1.1.2 Часть 2: (Продвинутый уровень) Лямбда-функции

Расширьте ваш интерпретатор для поддержки лямбда-функций и замыканий.

* Реализуйте специальную форму (lambda (arg1 arg2 ...) body)
* Когда eval встречает лямбду, он должен захватить текущее окружение (это замыкание)
* При вызове пользовательской функции, ее тело вычисляется в новом окружении,
  расширенном аргументами функции и захваченным окружением замыкания.

## 1.2 Ключевые концепции

* Алгебраические типы данных (ADT)
* Рекурсия и сопоставление с образцом (pattern matching)
* Управление состоянием (например, Map для окружения, возможно, с монадой State)
* Обработка ошибок (например, Either или Maybe для ошибок поиска)

Примерная сигнатура основной функции (можно менять по вашему усмотрению):

eval :: Env -> SExpr -> Either String SExpr

  где type Env = Map String SExpr

# 2) Реализация АВЛ-дерева

Обычное двоичное дерево поиска (BST) может стать несбалансированным, что приво-
дит к производительности O(n). АВЛ-дерево — это самобалансирующееся BST, которое
использует повороты, чтобы гарантировать, что высоты любых двух поддеревьев узла
различаются не более чем на единицу.

## 2.1 Описание

Определите тип данных для АВЛ-дерева. Каждый узел должен хранить свое значение,
левого и правого потомков и свою высоту.

```haskell
data AVLTree a
 = Empty
| Node ( AVLTree a) a ( AVLTree a) Int -- (Left , Value , Right , Height )
deriving ( Show )
```

Реализуйте следующие функции:

1. height :: AVLTree a -> Int: Вспомогательная функция, безопасно получающая вы-
соту дерева (0 для Empty).
2. balanceFactor :: AVLTree a -> Int: Вычисляет разницу в высоте между левым и
правым поддеревьями.
3. insert :: Ord a => a -> AVLTree a -> AVLTree a: Основная сложность. После обыч-
ной вставки BST вы должны пройти обратно вверх по дереву, обновить высоты и вы-
полнить повороты (левый, правый, лево-правый, право-левый), если balanceFactor
больше 1 или меньше -1.
4. delete :: Ord a => a -> AVLTree a -> AVLTree a: (Еще сложнее) Реализуйте уда-
ление, которое также требует ребалансировки после удаления узла.

## 2.2 Ключевые концепции

* Сложные рекурсивные структуры данных
* Поддержание инвариантов (фактор баланса)
* Аккуратное и сложное сопоставление с образцом
* Чисто функциональные манипуляции со структурами данных (без мутаций)
