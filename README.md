# Haskell-hard-tasks
# Простой интерпретатор Lisp

Ваша цель — написать интерпретатор для небольшого Lisp-подобного языка. 
Это задание проверяет проектирование типов данных, парсинг и управление состоянием 
(или рекурсию) для вычислений.

## 1.1 Описание

Определите тип данных для S-выражений (Символических Выражений), которые являются 
ядром Lisp. Выражение может быть атомом (числом или символом) или списком других выражений.

```haskell
-- | Тип данных для S-выражений (Lisp-подобный синтаксис)
data SExpr
  = Atom   String           -- символ / имя переменной
  | Number Integer          -- целое число
  | List   [SExpr]          -- список выражений (в том числе вызов функции)
  deriving (Show, Eq)
```

Ваш интерпретатор должен уметь вычислять эти выражения.

### 1.1.1 Часть 1: Вычислитель

Напишите функцию eval, которая принимает выражение и окружение 
(отображение имен переменных в значения) и возвращает новое выражение (результат).

• Числа вычисляются в самих себя.
• Символы (Атомы) ищутся в окружении.
• Списки — это вызовы функций. Первый элемент — функция, остальные — аргументы.

Реализуйте следующие встроенные функции и специальные формы:

* (+), (-), (*), (>) 
* (if condition then-expr else-expr)
* (define var-name value) — добавляет переменную в окружение

### 1.1.2 Часть 2: (Продвинутый уровень) Лямбда-функции

Расширьте ваш интерпретатор для поддержки лямбда-функций и замыканий.

* Реализуйте специальную форму (lambda (arg1 arg2 ...) body)
* Когда eval встречает лямбду, он должен захватить текущее окружение (это замыкание)
* При вызове пользовательской функции, ее тело вычисляется в новом окружении,
  расширенном аргументами функции и захваченным окружением замыкания.

## 1.2 Ключевые концепции

* Алгебраические типы данных (ADT)
* Рекурсия и сопоставление с образцом (pattern matching)
* Управление состоянием (например, Map для окружения, возможно, с монадой State)
* Обработка ошибок (например, Either или Maybe для ошибок поиска)

Примерная сигнатура основной функции (можно менять по вашему усмотрению):

eval :: Env -> SExpr -> Either String SExpr

  где type Env = Map String SExpr
