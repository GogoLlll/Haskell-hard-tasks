# 1) Простой интерпретатор Lisp

Написать интерпретатор для небольшого Lisp-подобного языка. 
Это задание проверяет проектирование типов данных, парсинг и управление состоянием 
(или рекурсию) для вычислений.

## 1.1 Описание

Определите тип данных для S-выражений (Символических Выражений), которые являются 
ядром Lisp. Выражение может быть атомом (числом или символом) или списком других выражений.

```haskell
-- | Тип данных для S-выражений (Lisp-подобный синтаксис)
data SExpr
  = Atom   String           -- символ / имя переменной
  | Number Integer          -- целое число
  | List   [SExpr]          -- список выражений (в том числе вызов функции)
  deriving (Show, Eq)
```

Ваш интерпретатор должен уметь вычислять эти выражения.

### 1.1.1 Часть 1: Вычислитель

Напишите функцию eval, которая принимает выражение и окружение 
(отображение имен переменных в значения) и возвращает новое выражение (результат).

• Числа вычисляются в самих себя.
• Символы (Атомы) ищутся в окружении.
• Списки — это вызовы функций. Первый элемент — функция, остальные — аргументы.

Реализуйте следующие встроенные функции и специальные формы:

* (+), (-), (*), (>) 
* (if condition then-expr else-expr)
* (define var-name value) — добавляет переменную в окружение

### 1.1.2 Часть 2: (Продвинутый уровень) Лямбда-функции

Расширьте ваш интерпретатор для поддержки лямбда-функций и замыканий.

* Реализуйте специальную форму (lambda (arg1 arg2 ...) body)
* Когда eval встречает лямбду, он должен захватить текущее окружение (это замыкание)
* При вызове пользовательской функции, ее тело вычисляется в новом окружении,
  расширенном аргументами функции и захваченным окружением замыкания.

## 1.2 Ключевые концепции

* Алгебраические типы данных (ADT)
* Рекурсия и сопоставление с образцом (pattern matching)
* Управление состоянием (например, Map для окружения, возможно, с монадой State)
* Обработка ошибок (например, Either или Maybe для ошибок поиска)

Примерная сигнатура основной функции (можно менять по вашему усмотрению):

eval :: Env -> SExpr -> Either String SExpr

  где type Env = Map String SExpr

# 2) Реализация АВЛ-дерева

Обычное двоичное дерево поиска (BST) может стать несбалансированным, что приводит к производительности O(n). АВЛ-дерево — это самобалансирующееся BST, которое
использует повороты, чтобы гарантировать, что высоты любых двух поддеревьев узла
различаются не более чем на единицу.

## 2.1 Описание

Определите тип данных для АВЛ-дерева. Каждый узел должен хранить свое значение,
левого и правого потомков и свою высоту.

```haskell
data AVLTree a
 = Empty
| Node ( AVLTree a) a ( AVLTree a) Int -- (Left , Value , Right , Height )
deriving ( Show )
```

Реализуйте следующие функции:

1. height :: AVLTree a -> Int: Вспомогательная функция, безопасно получающая высоту дерева (0 для Empty).
2. balanceFactor :: AVLTree a -> Int: Вычисляет разницу в высоте между левым и
правым поддеревьями.
3. insert :: Ord a => a -> AVLTree a -> AVLTree a: Основная сложность. После обычной вставки BST вы должны пройти обратно вверх по дереву, обновить высоты и выполнить повороты (левый, правый, лево-правый, право-левый), если balanceFactor
больше 1 или меньше -1.
4. delete :: Ord a => a -> AVLTree a -> AVLTree a: (Еще сложнее) Реализуйте удаление, которое также требует ребалансировки после удаления узла.

## 2.2 Ключевые концепции

* Сложные рекурсивные структуры данных
* Поддержание инвариантов (фактор баланса)
* Аккуратное и сложное сопоставление с образцом
* Чисто функциональные манипуляции со структурами данных (без мутаций)

# 3) Обобщенный алгоритм Дейкстры

реализация алгоритма Дейкстры для поиска кратчайших путей в графе. Задача состоит в
том, чтобы сделать это обобщенным, функциональным и эффективным способом.

## 3.1 Описание

Ваша функция должна иметь сигнатуру типа, похожую на эту:

```haskell
-- ( Vertex -> [( Vertex , Weight )]) :
-- ( Vertex -> Bool ) :
-- Vertex :
-- : Map

dijkstra
  :: ( Ord v, Ord w, Num w)
  => (v -> [(v, w)]) --
  -> (v -> Bool ) --
  -> v --
  -> Map v w -- Map
```

## 3.2 Детали реализации

* Вы не можете использовать мутабельные массивы. Вы должны использовать чисто
функциональные структуры данных.
* Вам понадобится очередь с приоритетом для хранения "границы"вершин для по-
сещения. Используйте Data.PSQueue (из пакета psqueues) или Data.PriorityQueue
(из pqueue).
* Вам также понадобится Map или Set для отслеживания посещенных узлов и кратчайших расстояний, найденных на данный момент.
* Ядром алгоритма будет рекурсивная вспомогательная функция, которая обрабатывает следующий узел из очереди с приоритетом, обновляет расстояния до его соседей
и добавляет их в очередь.

## 3.3 Ключевые концепции

* Перевод классического императивного алгоритма в функциональный стиль
* Использование стандартных библиотек (Map, Set и очередь с приоритетом)
* Ограничения классов типов для обобщенного программирования
* Управление сложным состоянием (расстояния, посещенные) через аргументы функций и рекурсию
